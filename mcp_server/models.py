# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T10:47:31+00:00

from __future__ import annotations

from datetime import date, datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, Field, RootModel, confloat


class APIKey(BaseModel):
    api_key_previous_version: Optional[str] = Field(
        None, description='Previous version of the API key'
    )
    api_key_version: Optional[str] = Field(None, description='API key version')
    client_id: Optional[str] = Field(None, description='Client ID of the API Key')
    creation_date: Optional[date] = Field(None, description='API key creation date')
    expiration_date: Optional[date] = Field(
        None, description='Expiration date of the API key'
    )
    key_name: Optional[str] = Field(
        None, description='Key name, equals user_key_name normalized'
    )
    update_date: Optional[date] = Field(
        None, description='Date when the API key version was changed'
    )
    user_key_name: Optional[str] = Field(None, description='User name of the API key')


class APIKeyVersionChangelog(BaseModel):
    added: Optional[List[str]] = Field(None, description='List of added features')
    changed: Optional[List[str]] = Field(None, description='List of changed features')
    deprecated: Optional[List[str]] = Field(
        None, description='List of deprecated features'
    )
    fixed: Optional[List[str]] = Field(None, description='List of fixed features')
    notes: Optional[str] = Field(None, description='Additional notes')
    removed: Optional[List[str]] = Field(None, description='List of removed features')
    security: Optional[List[str]] = Field(
        None, description='List of security features added'
    )


class BatchUploadInput(BaseModel):
    file: List[bytes] = Field(..., description='Uploaded file name')


class Country(Enum):
    co = 'co'
    ve = 've'
    cl = 'cl'
    mx = 'mx'
    pe = 'pe'
    do = 'do'
    sv = 'sv'
    gt = 'gt'
    bo = 'bo'
    cr = 'cr'
    ec = 'ec'
    pa = 'pa'
    br = 'br'


class DocumentType(Enum):
    national_id = 'national-id'
    passport = 'passport'
    foreign_id = 'foreign-id'
    nit = 'nit'
    diplomatic_id = 'diplomatic-id'
    civil_registration = 'civil-registration'
    identity_card = 'identity-card'
    foreigner_card = 'foreigner-card'
    professional_card = 'professional-card'
    military_card = 'military-card'
    pep = 'pep'
    nis = 'nis'
    dni = 'dni'
    rui = 'rui'
    license_plate = 'license-plate'
    query = 'query'
    name = 'name'
    rut = 'rut'
    nuip = 'nuip'
    foreign_societies = 'foreign-societies'
    escrow = 'escrow'
    individual_registration = 'individual-registration'
    general_registration = 'general-registration'
    curp = 'curp'
    dui = 'dui'
    driver_license = 'driver-license'
    ruc = 'ruc'


class Behavior(BaseModel):
    birth_date: date = Field(..., description='Birth date of reported person')
    country: Country = Field(..., description='Document country')
    creation_date: Optional[datetime] = Field(
        None, description='Feedback creation date'
    )
    document_id: str = Field(..., description='Person document ID')
    document_type: DocumentType = Field(
        ..., description='Document type associated with the background check'
    )
    email: str = Field(..., description='Reported person e-mail')
    feedback_date: date = Field(..., description='Behavior report date')
    first_name: str = Field(..., description='Person first name')
    last_name: str = Field(..., description='Person last name')
    phone_number: Optional[str] = Field(
        None, description='Phone number of the reported person'
    )
    reason: str = Field(..., description='Report reason')


class BehaviourOutput(BaseModel):
    behavior: List[Behavior] = Field(..., description='Behavior list')
    self: str = Field(..., description='Path to this resource')


class Change(BaseModel):
    dataset_score_changes: Optional[float] = Field(
        None, description='Old and new score map by dataset'
    )
    score_changes: Optional[List[Change]] = Field(
        None, description='Old and new score list'
    )


class Country1(Enum):
    ALL = 'ALL'
    BR = 'BR'
    CL = 'CL'
    CO = 'CO'
    CR = 'CR'
    EC = 'EC'
    MX = 'MX'
    PE = 'PE'
    AR = 'AR'


class NativeCountry(Enum):
    ad = 'ad'
    ae = 'ae'
    af = 'af'
    ag = 'ag'
    ai = 'ai'
    al = 'al'
    am = 'am'
    an = 'an'
    ao = 'ao'
    aq = 'aq'
    ar = 'ar'
    as_ = 'as'
    at = 'at'
    au = 'au'
    aw = 'aw'
    ax = 'ax'
    az = 'az'
    ba = 'ba'
    bb = 'bb'
    bd = 'bd'
    be = 'be'
    bf = 'bf'
    bg = 'bg'
    bh = 'bh'
    bi = 'bi'
    bj = 'bj'
    bm = 'bm'
    bn = 'bn'
    bo = 'bo'
    br = 'br'
    bs = 'bs'
    bt = 'bt'
    bv = 'bv'
    bw = 'bw'
    by = 'by'
    bz = 'bz'
    ca = 'ca'
    cc = 'cc'
    cd = 'cd'
    cf = 'cf'
    cg = 'cg'
    ch = 'ch'
    ci = 'ci'
    ck = 'ck'
    cl = 'cl'
    cm = 'cm'
    cn = 'cn'
    co = 'co'
    cr = 'cr'
    cu = 'cu'
    cv = 'cv'
    cx = 'cx'
    cy = 'cy'
    cz = 'cz'
    de = 'de'
    dj = 'dj'
    dk = 'dk'
    dm = 'dm'
    do = 'do'
    dz = 'dz'
    ea = 'ea'
    ec = 'ec'
    ee = 'ee'
    eg = 'eg'
    eh = 'eh'
    er = 'er'
    es = 'es'
    et = 'et'
    fi = 'fi'
    fj = 'fj'
    fk = 'fk'
    fm = 'fm'
    fo = 'fo'
    fr = 'fr'
    ga = 'ga'
    gb = 'gb'
    gd = 'gd'
    ge = 'ge'
    gf = 'gf'
    gg = 'gg'
    gh = 'gh'
    gi = 'gi'
    gl = 'gl'
    gm = 'gm'
    gn = 'gn'
    gp = 'gp'
    gq = 'gq'
    gr = 'gr'
    gs = 'gs'
    gt = 'gt'
    gu = 'gu'
    gw = 'gw'
    gy = 'gy'
    hk = 'hk'
    hm = 'hm'
    hn = 'hn'
    hr = 'hr'
    ht = 'ht'
    hu = 'hu'
    id = 'id'
    ie = 'ie'
    il = 'il'
    im = 'im'
    in_ = 'in'
    io = 'io'
    iq = 'iq'
    ir = 'ir'
    is_ = 'is'
    it = 'it'
    je = 'je'
    jm = 'jm'
    jo = 'jo'
    jp = 'jp'
    ke = 'ke'
    kg = 'kg'
    kh = 'kh'
    ki = 'ki'
    km = 'km'
    kn = 'kn'
    kp = 'kp'
    kr = 'kr'
    kw = 'kw'
    ky = 'ky'
    kz = 'kz'
    la = 'la'
    lb = 'lb'
    lc = 'lc'
    li = 'li'
    lk = 'lk'
    lr = 'lr'
    ls = 'ls'
    lt = 'lt'
    lu = 'lu'
    lv = 'lv'
    ly = 'ly'
    ma = 'ma'
    mc = 'mc'
    md = 'md'
    me = 'me'
    mg = 'mg'
    mh = 'mh'
    mk = 'mk'
    ml = 'ml'
    mm = 'mm'
    mn = 'mn'
    mo = 'mo'
    mp = 'mp'
    mq = 'mq'
    mr = 'mr'
    ms = 'ms'
    mt = 'mt'
    mu = 'mu'
    mv = 'mv'
    mw = 'mw'
    mx = 'mx'
    my = 'my'
    mz = 'mz'
    na = 'na'
    nc = 'nc'
    ne = 'ne'
    nf = 'nf'
    ng = 'ng'
    ni = 'ni'
    nl = 'nl'
    no = 'no'
    np = 'np'
    nr = 'nr'
    nu = 'nu'
    nz = 'nz'
    om = 'om'
    pa = 'pa'
    pe = 'pe'
    pf = 'pf'
    pg = 'pg'
    ph = 'ph'
    pk = 'pk'
    pl = 'pl'
    pm = 'pm'
    pn = 'pn'
    pr = 'pr'
    ps = 'ps'
    pt = 'pt'
    pw = 'pw'
    py = 'py'
    qa = 'qa'
    re = 're'
    ro = 'ro'
    rs = 'rs'
    ru = 'ru'
    rw = 'rw'
    sa = 'sa'
    sb = 'sb'
    sc = 'sc'
    sd = 'sd'
    se = 'se'
    sg = 'sg'
    sh = 'sh'
    si = 'si'
    sj = 'sj'
    sk = 'sk'
    sl = 'sl'
    sm = 'sm'
    sn = 'sn'
    so = 'so'
    sr = 'sr'
    st = 'st'
    sv = 'sv'
    sy = 'sy'
    sz = 'sz'
    tc = 'tc'
    td = 'td'
    tf = 'tf'
    tg = 'tg'
    th = 'th'
    tj = 'tj'
    tk = 'tk'
    tl = 'tl'
    tm = 'tm'
    tn = 'tn'
    to = 'to'
    tr = 'tr'
    tt = 'tt'
    tv = 'tv'
    tw = 'tw'
    tz = 'tz'
    ua = 'ua'
    ug = 'ug'
    um = 'um'
    us = 'us'
    uy = 'uy'
    uz = 'uz'
    va = 'va'
    vc = 'vc'
    ve = 've'
    vg = 'vg'
    vi = 'vi'
    vn = 'vn'
    vu = 'vu'
    wf = 'wf'
    ws = 'ws'
    ye = 'ye'
    yt = 'yt'
    za = 'za'
    zm = 'zm'
    zw = 'zw'


class Region(Enum):
    DF = 'DF'
    AC = 'AC'
    AL = 'AL'
    AP = 'AP'
    AM = 'AM'
    BA = 'BA'
    CE = 'CE'
    ES = 'ES'
    GO = 'GO'
    MA = 'MA'
    MT = 'MT'
    MS = 'MS'
    MG = 'MG'
    PA = 'PA'
    PB = 'PB'
    PR = 'PR'
    PE = 'PE'
    PI = 'PI'
    RJ = 'RJ'
    RN = 'RN'
    RS = 'RS'
    RO = 'RO'
    RR = 'RR'
    SC = 'SC'
    SP = 'SP'
    SE = 'SE'
    TO = 'TO'


class Status(Enum):
    not_started = 'not_started'
    in_progress = 'in_progress'
    completed = 'completed'
    error = 'error'
    delayed = 'delayed'


class Type(Enum):
    company = 'company'
    person = 'person'
    vehicle = 'vehicle'


class Group(Enum):
    profile = 'profile'
    legal = 'legal'
    affiliations = 'affiliations'
    vehicle = 'vehicle'
    global_ = 'global'
    media = 'media'
    unknown = 'unknown'


class Result(Enum):
    pending = 'pending'
    found = 'found'
    not_found = 'not_found'
    error = 'error'


class Comment(BaseModel):
    check_id: str = Field(..., description='Background check ID')
    content: str = Field(..., description='Comment content')
    creation_date: str = Field(..., description='Comment creation date')
    id: str = Field(..., description='Comment ID')
    parent_id: Optional[str] = Field(None, description='Comment parent ID')
    update_date: str = Field(..., description='Comment update date')
    username: str = Field(..., description='Comment creator username')


class CommentOutput(BaseModel):
    comment: Comment = Field(..., description='Comment object')
    self: str = Field(..., description='Current comment path')


class CommentsOutput(BaseModel):
    comments: List[Comment] = Field(..., description='Comment list')
    next: str = Field(..., description='Next page path')
    previous: str = Field(..., description='Previous page path')


class ContinuousCheckStatus(Enum):
    new = 'new'
    up = 'up'
    down = 'down'
    same = 'same'


class ContinuousCheckEntry(BaseModel):
    changes: Optional[List[Change]] = Field(
        None, description='Change list of background check scores'
    )
    check_id: Optional[str] = Field(None, description='Check ID')
    continuous_check_id: Optional[str] = Field(None, description='Continuous check ID')
    creation_date: Optional[date] = Field(
        None, description='Continuous check creation date in RFC3339 format\r\n'
    )
    previous_check_id: Optional[str] = Field(None, description='Previous check ID')


class CreateAPIKeyInput(BaseModel):
    days_exp: int = Field(
        ..., description='Time in days the API key will be valid for. 365 by default'
    )
    key_name: str = Field(..., description='API key name')
    tenant: str = Field(..., description='API key owner name')
    version: str = Field(..., description='API key version. 0 by default')


class Country2(Enum):
    co = 'co'
    ve = 've'
    cl = 'cl'
    mx = 'mx'
    pe = 'pe'
    do = 'do'
    sv = 'sv'
    gt = 'gt'
    bo = 'bo'
    cr = 'cr'
    ec = 'ec'
    pa = 'pa'
    br = 'br'


class Reason(Enum):
    rape = 'rape'
    drug_dealer = 'drug-dealer'
    sexual_harassment = 'sexual-harassment'
    theft = 'theft'
    fights = 'fights'
    aggressive_behaviour = 'aggressive-behaviour'
    identity_fraud = 'identity-fraud'
    drunk = 'drunk'
    drug_possession = 'drug-possession'
    absences = 'absences'
    tardiness = 'tardiness'
    confidentiality_breach = 'confidentiality-breach'
    good_reputation = 'good-reputation'


class CreateBehaviorInput(BaseModel):
    birth_date: datetime = Field(..., description='Birth date of reported person')
    country: Country2 = Field(..., description='Document country')
    document_id: str = Field(..., description='Person document ID')
    document_type: DocumentType = Field(
        ..., description='Document type associated with the background check'
    )
    email: str = Field(..., description='Reported person e-mail')
    feedback_date: datetime = Field(..., description='Behavior report date')
    first_name: str = Field(..., description='Person first name')
    last_name: str = Field(..., description='Person last name')
    phone_number: Optional[str] = Field(
        None, description='Phone number of the reported person'
    )
    reason: Reason = Field(..., description='Report reason')


class Country3(Enum):
    ALL = 'ALL'
    BR = 'BR'
    CL = 'CL'
    CO = 'CO'
    CR = 'CR'
    EC = 'EC'
    MX = 'MX'
    PE = 'PE'
    AR = 'AR'


class Type1(Enum):
    person = 'person'
    vehicle = 'vehicle'
    company = 'company'
    custom_type_name = 'custom_type_name'


class CreateCheckInput(BaseModel):
    birth_certificate: Optional[str] = Field(
        None, description='Person birth certificate'
    )
    company_name: Optional[str] = Field(
        None,
        description='Company name "Don\'t forget this required field to complete background checks in Brazil"',
    )
    country: Country3 = Field(..., description='Document country')
    date_of_birth: Optional[date] = Field(
        None,
        description='Person birthdate. This date is used to get some additional information about a person and to filter homonyms in some cases. YYYY-MM-DD format, Required for complete background checks in Brazil',
    )
    diplomatic_id: Optional[str] = Field(None, description='Diplomatic ID')
    driver_license: Optional[str] = Field(None, description="Driver's license number")
    escrow: Optional[str] = Field(None, description='Colombian escrow')
    first_name: Optional[str] = Field(
        None,
        description='Person or entity first name. If the document type and number are not provided, the report might include homonyms. Required when searching by first name, Required in order to get complete background checks in Brazil',
    )
    force_creation: Optional[bool] = Field(
        None,
        description='Forces a new background check creation when true. Reuses recently created background checks otherwise',
    )
    foreign_id: Optional[str] = Field(None, description='Person foreign ID')
    issue_date: Optional[date] = Field(
        None,
        description='Person document issue date in "YYYY-mm-dd" format (e.g. 2008-12-31) . This date is used to get some additional information about a person in some cases',
    )
    last_name: Optional[str] = Field(
        None,
        description='Person or entity last name. If the document type and number are not provided, the report might include homonyms. Required when searching by last name. Required in order to get complete background checks in Brazil',
    )
    license_plate: Optional[str] = Field(None, description='Vehicle license plate')
    national_id: Optional[str] = Field(None, description='National ID')
    native_country: Optional[str] = Field(None, description='Country of birth')
    owner_document_id: Optional[str] = Field(
        None, description='National ID of the vehicle owner'
    )
    owner_document_type: Optional[str] = Field(
        None, description='National ID, foreign ID, or tax ID'
    )
    passport: Optional[str] = Field(None, description='Person passport')
    payment_date: Optional[date] = Field(
        None, description='Payment day of a vehicle circulation permit (Chile only)'
    )
    pep: Optional[str] = Field(
        None, description='ID for Venezuelans working in Colombia'
    )
    phone_number: Optional[str] = Field(
        None,
        description='Person phone number. Required by law to notify the person their background is being checked',
    )
    professional_card: Optional[str] = Field(None, description='Professional ID card')
    ptp: Optional[str] = Field(None, description='ID for Venezuelans working in Peru')
    region: Optional[Region] = Field(
        None,
        description='Region where the background is to be checked in addition to the region where the person is from. By default, background checks in Brazil are performed in the region where the person is from. Required for Brazil only. Allowed values are: DF: Distrito Federal, AC: Acre, AL: Alagoas, AP: Amapá, AM: Amazonas, BA: Bahía, CE: Ceará, ES: Espírito Santo, GO: Goiás, MA: Maranhão, MT: Mato Grosso, MS: Mato Grosso do Sul, MG: Minas Gerais, PA: Pará, PB: Paraíba, PR: Paraná, PE: Pernambuco, PI: Piauí, RJ: Río de Janeiro, RN: Río Grande do Norte, RS: Río Grande do Sul, RO: Rondônia, RR: Roraima, SC: Santa Catarina, SP: São Paulo, SE: Sergipe, TO : Tocantins.',
    )
    report_id: Optional[str] = Field(
        None, description='Report ID the background check will be inserted into'
    )
    state_id: Optional[str] = Field(
        None,
        description=' Used for the RG (Registro Geral) identification in Brazil. This identification has different formats according to the state that issues the document. It can have numbers and letters but other characters (- * , . ) are omitted, Required in order to get complete background checks in Brazil',
    )
    tax_id: Optional[str] = Field(None, description='Company ID used for tax payments')
    type: Type1 = Field(..., description='Background check type')
    user_authorized: Optional[bool] = Field(
        None,
        description='Indicates whether the person subject to the validation authorized the validation. Must be true in order to proceed [Required for API key V1 or later]',
    )
    vehicle_id: Optional[str] = Field(None, description='Vehicle license plate')
    verification_code: Optional[str] = Field(
        None,
        description='Verification code registered for criminal records in Peru only',
    )
    watch: Optional[str] = Field(
        None,
        description='Indicates whether the check score is to be periodically revised and its frequency. It can be daily, weekly, monthly, yearly or have a custom frequency written as a number accompanied by d: day, w: week, m: month, y: year for instance: 3d: every three days, 2w: every two weeks. Ignore this field if the check is only to be performed once',
    )


class CreateCommentInput(BaseModel):
    content: Optional[Any] = Field(None, description='Comment content')


class CreateConfigInput(BaseModel):
    country: Country3 = Field(
        ...,
        description='Country where this set of rules applies. Use "all" if the check type searches by name by relying on international databases',
    )
    dataset_affiliations_and_insurances: Optional[float] = Field(
        None,
        description='Affiliation and insurance weight for score calculation. From 0 to 1',
    )
    dataset_alert_in_media: Optional[float] = Field(
        None, description='Alert in media weight for score calculation. From 0 to 1'
    )
    dataset_business_background: Optional[float] = Field(
        None,
        description='Business background weight for score calculation. From 0 to 1',
    )
    dataset_criminal_record: Optional[float] = Field(
        None, description='Criminal record weight for score calculation. From 0 to 1'
    )
    dataset_driving_licenses: Optional[float] = Field(
        None, description='Driving license weight for score calculation. From 0 to 1'
    )
    dataset_international_background: Optional[float] = Field(
        None,
        description='International background weight for score calculation. From 0 to 1',
    )
    dataset_legal_background: Optional[float] = Field(
        None, description='Legal background weight for score calculation. From 0 to 1'
    )
    dataset_personal_identity: Optional[float] = Field(
        None, description='Personal identity weight for score calculation. From 0 to 1'
    )
    dataset_professional_background: Optional[float] = Field(
        None,
        description='Professional background weight for score calculation. From 0 to 1',
    )
    dataset_taxes_and_finances: Optional[float] = Field(
        None,
        description='Taxes and financial background weight for score calculation. From 0 to 1',
    )
    dataset_traffic_fines: Optional[float] = Field(
        None, description='Traffic fines weight for score calculation. From 0 to 1'
    )
    dataset_vehicle_information: Optional[float] = Field(
        None,
        description='Vehicle information weight for score calculation. From 0 to 1',
    )
    dataset_vehicle_permits: Optional[float] = Field(
        None,
        description='Vehicle certificate background weight for score calculation. From 0 to 1',
    )
    type: str = Field(
        ...,
        description='Score configuration name. It cannot be person, vehicle, or company',
    )


class CreateContinuousCheckInput(BaseModel):
    check_id: Optional[str] = Field(
        None, description='Background checks to be processed recurrently'
    )
    frequency: Optional[str] = Field(
        None,
        description='Time between background checks. It can be daily, weekly, monthly, yearly or have a custom frequency written as a number accompanied by d: day, w: week, m: month, y: year for instance: 3d: every three days, 2w: every two weeks',
    )
    status: Optional[str] = Field(
        None,
        description='Indicates whether the background checks must be processed recurrently (enabled | disabled)',
    )


class EventType(Enum):
    all = 'all'
    check = 'check'
    continuous_check = 'continuous_check'


class Status1(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class SubscriberLanguage(Enum):
    af = 'af'
    ar = 'ar'
    ca = 'ca'
    cs = 'cs'
    da = 'da'
    de = 'de'
    el = 'el'
    en = 'en'
    es = 'es'
    fi = 'fi'
    fr = 'fr'
    he = 'he'
    hi = 'hi'
    hr = 'hr'
    hu = 'hu'
    id = 'id'
    it = 'it'
    ja = 'ja'
    ko = 'ko'
    ms = 'ms'
    nb = 'nb'
    nl = 'nl'
    pl = 'pl'
    pt = 'pt'
    pr_BR = 'pr-BR'
    ro = 'ro'
    ru = 'ru'
    sv = 'sv'
    th = 'th'
    tl = 'tl'
    tr = 'tr'
    vi = 'vi'
    zh = 'zh'
    zh_CN = 'zh-CN'
    zh_HK = 'zh-HK'


class SubscriberType(Enum):
    web = 'web'
    email = 'email'


class CreateHookInput(BaseModel):
    actions: Optional[List[str]] = Field(
        None,
        description='Actions you want to be notified. Possible inputs are created, started, and finished or any combination of those three',
    )
    event_type: EventType = Field(
        ..., description='The entity events the client wants to subscribe'
    )
    status: Optional[Status1] = Field(
        None,
        description='indicates whether the hook is active or not. enabled by default',
    )
    subscriber_address: Optional[str] = Field(
        None,
        description='Email address where the notification is to be sent. Required if subscriber_type was set to email',
    )
    subscriber_language: Optional[SubscriberLanguage] = Field(
        None, description='Language for the notification to be sent'
    )
    subscriber_name: Optional[str] = Field(
        None, description='Name of the person to be notified'
    )
    subscriber_type: SubscriberType = Field(
        ..., description='A platform with an endpoint ready to process the information'
    )
    subscriber_url: Optional[str] = Field(
        None,
        description='URL where the notification is to be sent. Required only if subscriber_type is set to web',
    )


class CreateReportInput(BaseModel):
    name: str = Field(..., description='Report name')


class Level(Enum):
    danger = 'danger'
    warning = 'warning'
    success = 'success'
    info = 'info'


class Operation(Enum):
    field__ = '=='
    field___1 = '>='
    field_ = '>'
    field__1 = '<'
    field___2 = '<='


class CreateRuleInput(BaseModel):
    label: str = Field(..., description='Used on the scores that fulfil this rule')
    level: Level = Field(..., description='Rule nature')
    operation: Operation = Field(
        ..., description='Comparison between the rule and score values'
    )
    value: float = Field(..., description='Rule value')


class CreateUserInput(BaseModel):
    country: str = Field(..., description='User country')
    email: str = Field(..., description='User account email')
    phone_number: str = Field(
        ..., description='User phone number (including country code)'
    )
    tenant: str = Field(..., description='Account name')


class Database(BaseModel):
    data_sets: Optional[List[str]] = Field(
        None,
        description='List of data sets fed by the database. It can contain ``affiliations_and_insurances``, ``alert_in:media``, ``business_background``, ``criminal_record``, ``driving_licenses``, ``international_background``, ``legal_background``, ``personal_identity``, ``permiso_de_circulación_covid-19``, ``professional_background``, ``traffic_fines``, ``vehicle_information``, ``vehicle_permits``, ``behaviour_and_reputation``, or ``taxes_and_finances``',
    )
    database_id: Optional[str] = Field(None, description='Database identifier')
    database_name: Optional[str] = Field(
        None,
        description='Database name. Do not use this field to identify the database as it might change, use database_id instead',
    )
    hourly_status: Optional[List[str]] = Field(
        None,
        description='An hourly list of the database statuses. The ``operational`` status means the database executions were at least 90% successful, ``degraded_performance`` means the database executions were from 50 to 90% successful, ``partial_outage`` means the database executions were from 10 to 50% sucessful, ``major_outage`` means the database executions were under 10% successful. ``under_maintenance`` means the database is temporarily out of service for maintenance, ``deprecated`` means the database is permanently out of service, ``undetermined`` means there was no enough data to assess the database status',
    )


class DeleteAPIKeyInput(BaseModel):
    key_name: str = Field(..., description='Key name')


class DeleteConfigInput(BaseModel):
    pass


class DeleteUserInput(BaseModel):
    email: str = Field(..., description='email of the API key user')


class Error(BaseModel):
    code: str = Field(..., description='Error code')
    message: str = Field(..., description='Message describing the error')


class GetContiuousCheckHistoryOutput(BaseModel):
    history: List[Change] = Field(
        ..., description='List of background check changelogs'
    )
    next: Optional[str] = Field(None, description='Next page URL')
    self: Optional[str] = Field(None, description='Current page URL')


class GetHealthDashboardInput(BaseModel):
    country: str = Field(
        ..., description='Database country in ISO 3166 code. Must be in all caps.'
    )
    unixTimestampSeconds: str = Field(
        ..., description='Unix timestamp. Send the current time to know the status'
    )
    unixtimezoneOffsetSeconds: str = Field(
        ...,
        description='Offset between the local time and the UTC time in seconds. (e.g., Colombia is located at UTC -18000 seconds)',
    )


class EventType1(Enum):
    all = 'all'
    check = 'check'


class Hook(BaseModel):
    actions: Optional[List[str]] = Field(
        None,
        description='Actions you want to be notified. Possible inputs are created, started, and finished or any combination of those three',
    )
    event_type: Optional[EventType1] = Field(
        None,
        description='Entity events you want to be notified. If all is selected, there is no need to enter actions',
    )
    signing_key: Optional[str] = Field(
        None,
        description='Secret random hexadecimal key used to sign the event and confirm its legitimacy. Signing keys are used to decode the JWT you get as payload from events',
    )
    status: Optional[Status1] = Field(
        None,
        description='indicates whether the hook is active or not. enabled by default',
    )
    subscriber_type: Optional[str] = Field(
        None,
        description='Platform with an endpoint ready to process the information. Only web is supported currently',
    )
    subscriber_url: Optional[str] = Field(
        None,
        description='Link where notification requests will be sent, required when subscriber_type is web',
    )


class HookOutput(BaseModel):
    hooks: Optional[List[Hook]] = Field(
        None, description='List of hooks in current page.'
    )
    next: Optional[str] = Field(None, description='Next page URL')
    self: Optional[str] = Field(None, description='Current page URL')
    signing_key: Optional[str] = Field(
        None,
        description='HMAC key needed to decode the JWTs you will receive. All events are sent in JWT format, this key is needed in order to ensure that only authorized users can decode the information.',
    )


class NameFound(BaseModel):
    count: int = Field(
        ..., description='Times this name was found during the background check process'
    )
    first_name: str = Field(..., description='First name found in the background check')
    last_name: str = Field(..., description='Last name found in the background check')


class Report(BaseModel):
    created_by: Optional[str] = Field(
        None, description='name of the user who created the report'
    )
    created_checks_count: Optional[int] = Field(
        None,
        description='Amount of created checks. Returned only when a file is uploaded',
    )
    creation_date: datetime = Field(..., description='Report creation date')
    has_data: Optional[bool] = Field(
        None, description='Indicates whether the report has an associated file'
    )
    id: str = Field(..., description='Report ID')
    invalid_checks_count: Optional[int] = Field(
        None,
        description='number of invalid rows in the uploaded file. Returned only when a file is uploaded',
    )
    name: str = Field(..., description='Report name')
    size: Optional[int] = Field(
        None,
        description='Uploaded file row count. Returned only when a file is uploaded',
    )
    update_date: datetime = Field(
        ..., description='Latest modification date of the report'
    )


class ReportOutput(BaseModel):
    checks: str = Field(..., description='Path to background check list')
    report: Report = Field(..., description='Report searched')
    self: Optional[str] = Field(None, description='Path to this resource')


class ReportsOutput(BaseModel):
    next: Optional[str] = Field(None, description='Next page path')
    reports: List[Report] = Field(..., description='Report list')
    self: str = Field(..., description='Current page path')


class Rule(BaseModel):
    level: Level = Field(..., description='Rule nature')
    operation: Operation = Field(
        ..., description='Comparison between the rule and score values'
    )
    outcome_label: Optional[str] = Field(
        None, description='Used on the scores that fulfil this rule'
    )
    value: float = Field(..., description='Rule value')


class RuleOutput(BaseModel):
    rule: Rule = Field(..., description='Rule object')
    self: str = Field(..., description='Path to this rule')


class DataSet(Enum):
    affiliations_and_insurances = 'affiliations_and_insurances'
    alert_in_media = 'alert_in_media'
    behavior = 'behavior'
    business_background = 'business_background'
    criminal_record = 'criminal_record'
    driving_licenses = 'driving_licenses'
    international_background = 'international_background'
    legal_background = 'legal_background'
    personal_identity = 'personal_identity'
    professional_background = 'professional_background'
    traffic_fines = 'traffic_fines'
    vehicle_information = 'vehicle_information'
    vehicle_permits = 'vehicle_permits'
    taxes_and_finances = 'taxes_and_finances'


class Result1(Enum):
    pending = 'pending'
    found = 'found'
    not_found = 'not_found'
    error = 'error'
    delayed = 'delayed'
    ignored = 'ignored'


class Severity(Enum):
    unknown = 'unknown'
    none = 'none'
    very_low = 'very_low'
    low = 'low'
    medium = 'medium'
    high = 'high'
    very_high = 'very_high'


class ScoreConfig(BaseModel):
    data_set: str = Field(..., description='Background check dataset')
    weight: str = Field(..., description='Dataset weight for score calculation')


class ScoreConfigOutput(BaseModel):
    ScoreConfigByCountry: Optional[List[ScoreConfig]] = Field(
        None, description='List of score configs that apply for the country'
    )


class ScoreConfigsOutput(BaseModel):
    score_configs: List[ScoreConfigOutput] = Field(
        ..., description='The list of score configs'
    )


class ScoreDetail(BaseModel):
    result: Result1 = Field(
        ...,
        description='Overall result of the data collected. If at least one collected data status is found, the result will be found, otherwise, it will be the most frecuent status',
    )
    score: float = Field(
        ...,
        description='Dataset score. Number between 0 and 1 where 1 is the best score.',
    )
    severity: Severity = Field(
        ...,
        description='Risk asociated with each category for the search according to the information found. None is returned when the person, vehicle or company is in the clear. Unknown is returned when the score is none',
    )


class Status3(Enum):
    not_started = 'not_started'
    completed = 'completed'
    expired = 'expired'
    error = 'error'
    delayed = 'delayed'
    skipped = 'skipped'


class StatusModel(BaseModel):
    data_set: Optional[DataSet] = Field(None, description='Background check dataset')
    database_id: Optional[str] = Field(
        None, description='Database ID. Can be used to verify the database status'
    )
    database_name: Optional[str] = Field(
        None,
        description='Background check database name. Do not use this field to identify the database as it may change during the check execution. Use database_id instead',
    )
    invalid_inputs: Optional[List[str]] = Field(
        None, description='List of missing or invalid inputs'
    )
    status: Optional[Status3] = Field(
        None,
        description='Result status of the background check. **Not_started** means the background check is still in queue, since there is a limit of background checks that can be processed simultaneously, **completed** means the search finished successfully, **error** means the search failed, **expired** means the search took too long to finish and therefore failed, **skipped** means the search failed because a wrong number or type of parameters was provided, **delayed** means the search is waiting for an additional requirement to be met and can last up to 3 days',
    )


class Subscriber(BaseModel):
    url: str = Field(
        ...,
        description='Link where notification requests will be sent in case subscriber_type is web',
    )


class Gender(Enum):
    male = 'male'
    female = 'female'


class IdentityStatus(Enum):
    found = 'found'
    not_found = 'not_found'
    dead = 'dead'


class Summary(BaseModel):
    date_of_birth: Optional[datetime] = Field(
        None, description='Person date of birth in RFC3339 format'
    )
    death_date: Optional[datetime] = Field(None, description='Person date of death')
    drivers_license: Optional[str] = Field(None, description="Person driver's license")
    gender: Optional[Gender] = Field(None, description='Person gender')
    identity_status: Optional[IdentityStatus] = Field(
        None,
        description='Indicates whether a person was found, found as dead or not found at all',
    )
    names_found: List[NameFound] = Field(
        ..., description='Names found during the background check process'
    )
    nss: Optional[str] = Field(
        None, description='Social security number of the person (Mexico)'
    )
    rfc: Optional[str] = Field(
        None, description='Federal taxpayer registration number of the person'
    )


class TableCell(BaseModel):
    label: str = Field(..., description='Cell label')
    value: str = Field(..., description='Cell value')


class TableRow(BaseModel):
    cells: List[TableCell] = Field(..., description='Row cells')


class UpdateAPIKeyInput(BaseModel):
    api_key_version: str = Field(..., description='API key Version')
    key_name: str = Field(..., description='API key name')


class Status4(Enum):
    enabled = 'enabled'
    disabled = 'disabled'


class UpdateContinuousCheckInput(BaseModel):
    frequency: str = Field(..., description='Time between background checks')
    status: Status4 = Field(
        ...,
        description='Indicates whether the background checks must be processed recurrently',
    )


class UserStatus(Enum):
    FORCE_CHANGE_PASSWORD = 'FORCE_CHANGE_PASSWORD'
    CONFIRMED = 'CONFIRMED'


class User(BaseModel):
    email: Optional[str] = Field(None, description='User email')
    enabled: Optional[bool] = Field(
        None, description='Indicates whether the user is allowed to access or not'
    )
    user_creation_date: Optional[str] = Field(
        None, description='Date on which the user was created'
    )
    user_status: Optional[UserStatus] = Field(
        None,
        description='Indicates whether the user is confirmed or needs to change their password',
    )
    username: Optional[str] = Field(None, description='Username')


class VehicleSummary(BaseModel):
    capacity: Optional[int] = Field(
        None, description='Number of passengers allowed to travel in the vehicle'
    )
    color: Optional[str] = Field(None, description='Vehicle color')
    license_plate: Optional[str] = Field(None, description='Vehicle license plate')
    manufacturer: Optional[str] = Field(None, description='Vehicle manufacturer')
    model: Optional[str] = Field(None, description='Vehicle model')
    number_of_doors: Optional[int] = Field(None, description='Vehicle door count')
    obligatory_insurance_expiration_date: Optional[date] = Field(
        None, description='Expiration date of the vehicle compulsory insurance '
    )
    obligatory_insurance_status: Optional[str] = Field(
        None, description='Status of the vehicle compulsory insurances'
    )
    service_type: Optional[str] = Field(None, description='Vehicle service type')
    vehicle_category: Optional[str] = Field(None, description='Vehicle category')
    vehicle_id: Optional[str] = Field(None, description='Vehicle ID')
    vehicle_type: Optional[str] = Field(None, description='Vehicle type')
    year: Optional[int] = Field(None, description='Vehicle model year')


class Input(Enum):
    document_expedition_date = 'document_expedition_date'


class WrongInput(BaseModel):
    Input_1: Optional[Input] = Field(
        None,
        alias='Input',
        description='Parameter entered that differs from the information obtained',
    )


class V1BehaviorPostResponse(RootModel[List[Error]]):
    root: List[Error]


class TruoraPriority(Enum):
    low = 'low'
    medium = 'medium'
    high = 'high'


class V1ChecksHealthGetResponse(RootModel[List[Database]]):
    root: List[Database]


class Country5(Enum):
    BR = 'BR'
    CL = 'CL'
    CO = 'CO'
    CR = 'CR'
    EC = 'EC'
    MX = 'MX'
    PE = 'PE'
    ALL = 'ALL'


class APIKeyVersion(BaseModel):
    changelog: Optional[APIKeyVersionChangelog] = Field(
        None, description='Changes made to the API key version'
    )
    expiration_date: Optional[date] = Field(
        None, description='Expiration date of the API key version'
    )
    release_date: Optional[date] = Field(
        None, description='Release date of the API key version'
    )
    version: Optional[str] = Field(None, description='API key version')


class CompanySummary(BaseModel):
    names_found: Optional[List[NameFound]] = Field(
        None, description='Names found during the background check process'
    )


class Config(BaseModel):
    client_id: str = Field(..., description='Client ID')
    config_id: str = Field(..., description='Configuration ID')
    score_config: ScoreConfig = Field(..., description='Score ID')


class Score(BaseModel):
    by_id: ScoreDetail = Field(
        ...,
        description='Dataset score detail of the background check result by identity document',
    )
    by_name: ScoreDetail = Field(
        ...,
        description='Score detail of the background check results by name. Might include homonyms',
    )
    data_set: DataSet = Field(..., description='Dataset summed up to create the score')
    result: Optional[Result1] = Field(
        None,
        description='Overall result of the data collected. If at least one collected data status is found, the result will be found, otherwise, it will be the most frecuent status',
    )
    score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='Dataset score. Number between 0 and 1 where 1 is the best score.',
    )
    severity: Severity = Field(
        ...,
        description='Risk asociated with each category for the search according to the information found. None is returned when the person, vehicle or company is in the clear. Unknown is returned when the score is none due to a problem with one of the searches',
    )


class Table(BaseModel):
    rows: List[TableRow] = Field(..., description='Table rows')
    title: str = Field(..., description='Table title')


class Check(BaseModel):
    birth_certificate: Optional[str] = Field(
        None, description='Person birth certificate'
    )
    check_id: str = Field(..., description='Background check ID')
    company_summary: Optional[CompanySummary] = Field(
        None, description='Summary of the company background check process'
    )
    country: Country1 = Field(..., description='ID Document country')
    creation_date: datetime = Field(..., description='Background check creation date')
    date_of_birth: Optional[datetime] = Field(
        None,
        description='Person birthdate. Shown only if provided during check creation. YYYY-MM-DD format',
    )
    diplomatic_id: Optional[str] = Field(None, description='Person diplomatic id')
    driver_license: Optional[str] = Field(None, description="Person driver's license")
    first_name: Optional[str] = Field(
        None,
        description='Person or entity first name. Shown only if provided during check creation',
    )
    foreign_id: Optional[str] = Field(None, description='Person foreign identification')
    homonym_probability: Optional[float] = Field(
        None,
        description='[Experimental] Analyzes the probability that the results by name are attributed to a homonym. Number between 0 and 1 where 1 is the the greatest probability',
    )
    homonym_score: Optional[confloat(ge=0.0, le=1.0)] = Field(
        None,
        description='Background check score including results by name only. This might contain homonym information',
    )
    homonym_scores: Optional[List[Score]] = Field(
        None,
        description='Background check scores by name for each profile group. [Deprecated for API key V1]',
    )
    id_score: float = Field(
        ...,
        description='Background check score regarding results by ID number only. It is a number between 0 and 1 where 1 is the best score. This result is a weighted average of the id_scores listed under scores.',
    )
    issue_date: Optional[datetime] = Field(
        None, description='Issue date of the person ID'
    )
    last_name: Optional[str] = Field(
        None,
        description='Person or entity last name. Shown only if provided during check creation',
    )
    license_plate: Optional[str] = Field(None, description='Vehicle license plate')
    national_id: Optional[str] = Field(
        None, description='Person national identification'
    )
    native_country: Optional[NativeCountry] = Field(
        None, description='Person origin country'
    )
    owner_document_id: Optional[str] = Field(
        None, description='Vehicle owner identification'
    )
    owner_document_type: Optional[str] = Field(
        None, description='Vehicle owner document type'
    )
    passport: Optional[str] = Field(None, description='Person passport')
    payment_date: Optional[str] = Field(
        None, description='Vehicle license payment date'
    )
    pep: Optional[str] = Field(
        None, description='Colombian PEP idenfitication for Venezuelans'
    )
    phone_number: Optional[str] = Field(
        None,
        description='Person phone number. Required by law in order to notify the person their background is being checked',
    )
    professional_card: Optional[str] = Field(
        None, description='Person professional card number'
    )
    ptp: Optional[str] = Field(
        None, description='Temporary residence permit of the person'
    )
    region: Optional[Region] = Field(
        None,
        description='Region where the background is to be checked. By default, background checks in Brazil are performed in region where the person is from. Applies for some Brazil collectors only. Allowed values are: DF: Distrito Federal, AC: Acre, AL: Alagoas, AP: Amapá, AM: Amazonas, BA: Bahía, CE: Ceará, ES: Espírito Santo, GO: Goiás, MA: Maranhão, MT: Mato Grosso, MS: Mato Grosso do Sul, MG: Minas Gerais, PA: Pará, PB: Paraíba, PR: Paraná, PE: Pernambuco, PI: Piauí, RJ: Río de Janeiro, RN: Río Grande do Norte, RS: Río Grande do Sul, RO: Rondônia, RR: Roraima, SC: Santa Catarina, SP: São Paulo, SE: Sergipe, TO : Tocantins.\r\n',
    )
    report_id: Optional[str] = Field(
        None, description='Report ID the background check is associated with'
    )
    score: confloat(ge=0.0, le=1.0) = Field(
        ...,
        description='Background check score. Number between 0 and 1 where 1 is the best score',
    )
    scores: Optional[List[Score]] = Field(
        None, description='Background check score of each profile group and dataset'
    )
    status: Status = Field(
        ...,
        description='Result status of the background check. **Not_started** means the background check is still in queue, since there is a limit of background checks that can be processed simultaneously, **completed** means the check finished successfully, **error** means the check failed, **in_progress** means the check is currently being processed, **delayed** means the check is waiting for an additional requirement to be met, this can last up to 3 days. **Completed** and **error** are the two only final statuses',
    )
    statuses: List[StatusModel] = Field(..., description='Database status list')
    summary: Summary = Field(..., description='Background check process summary')
    tax_id: Optional[str] = Field(None, description='Person or company tax id')
    type: Type = Field(..., description='Background check type')
    update_date: Optional[datetime] = Field(
        None, description='Background check update date'
    )
    vehicle_id: Optional[str] = Field(None, description='Vehicle identification')
    vehicle_summary: Optional[VehicleSummary] = Field(
        None, description='Summary of the vehicle background check process'
    )
    wrong_inputs: Optional[List[WrongInput]] = Field(
        None,
        description='List of parameters entered during background check creation that do not match the information obtained',
    )


class CheckDetails(BaseModel):
    check_id: str = Field(..., description='Associated background check ID')
    data_set: str = Field(..., description='Details dataset')
    database_name: str = Field(
        ...,
        description='Database name. Do not use this field to identify the database as its value may vary as the check is completed',
    )
    group: Group = Field(..., description='table group type')
    id: str = Field(..., description='Detail ID')
    result: Result = Field(..., description='Database result')
    score: float = Field(
        ...,
        description='Partial detail score. Scores are aggregated later in the background check',
    )
    tables: List[Table] = Field(..., description='Query detailed information')


class CheckDetailsOutput(BaseModel):
    details: List[CheckDetails] = Field(..., description='Detail list')
    next: Optional[str] = Field(None, description='Next page path')
    self: str = Field(..., description='Current page path')


class CheckOutput(BaseModel):
    check: Check = Field(..., description='Background check data found')
    details: str = Field(..., description='Detail path')
    self: str = Field(..., description='Background check URL')


class ChecksOutput(BaseModel):
    checks: List[Check] = Field(..., description='Background check list in the page')
    next: Optional[str] = Field(None, description='Next page path')
    self: str = Field(..., description='Current page path')


class ContinuousCheck(BaseModel):
    ContinuousCheckID: Optional[str] = Field(
        None, description='Continuous check ID [partition key and sort key]'
    )
    ContinuousCheckStatus_1: ContinuousCheckStatus = Field(
        ...,
        alias='ContinuousCheckStatus',
        description='Shows whether the background check score rose, fell, stood the same or was just created',
    )
    CreationDate: Optional[date] = Field(
        None, description='Continuous check creation date in RFC3339 format'
    )
    Enabled: Optional[bool] = Field(
        None, description='Indicates whether continuous check is enabled'
    )
    Frequency: str = Field(
        ...,
        description='Time between background checks. It can be daily, weekly, monthly, yearly or have a custom frequency written as a number accompanied by d: day, w: week, m: month, y: year for instance: 3d: every three days, 2w: every two weeks',
    )
    History: Optional[ContinuousCheckEntry] = Field(
        None, description='Background check changelog'
    )
    LastCheckID: str = Field(..., description='Last check ID')
    NextRunDate: Optional[date] = Field(
        None, description='Next background check date, in RFC3339 format (without time)'
    )
    OriginalCheck: Optional[Check] = Field(None, description='First check')
    UpdateDate: Optional[date] = Field(
        None, description='Continuous check update date in RFC3339 format'
    )


class ListContinuousChecksOutput(BaseModel):
    continuous_checks: Optional[List[Check]] = Field(
        None,
        description='List of continuous checks in current page\r\n\r\nDefault: all',
    )
    next: Optional[str] = Field(None, description='Next page URL')
    self: Optional[str] = Field(None, description='Current page URL')


Change.model_rebuild()
